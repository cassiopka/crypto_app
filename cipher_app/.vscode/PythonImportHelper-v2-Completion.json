[
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "atbash_cipher",
        "importPath": "ciphers.atbash_cipher",
        "description": "ciphers.atbash_cipher",
        "isExtraImport": true,
        "detail": "ciphers.atbash_cipher",
        "documentation": {}
    },
    {
        "label": "atbash_decipher",
        "importPath": "ciphers.atbash_cipher",
        "description": "ciphers.atbash_cipher",
        "isExtraImport": true,
        "detail": "ciphers.atbash_cipher",
        "documentation": {}
    },
    {
        "label": "caesar_cipher",
        "importPath": "ciphers.caesar_cipher",
        "description": "ciphers.caesar_cipher",
        "isExtraImport": true,
        "detail": "ciphers.caesar_cipher",
        "documentation": {}
    },
    {
        "label": "caesar_decipher",
        "importPath": "ciphers.caesar_cipher",
        "description": "ciphers.caesar_cipher",
        "isExtraImport": true,
        "detail": "ciphers.caesar_cipher",
        "documentation": {}
    },
    {
        "label": "polybius_square_cipher",
        "importPath": "ciphers.polybius_square_cipher",
        "description": "ciphers.polybius_square_cipher",
        "isExtraImport": true,
        "detail": "ciphers.polybius_square_cipher",
        "documentation": {}
    },
    {
        "label": "polybius_square_decipher",
        "importPath": "ciphers.polybius_square_cipher",
        "description": "ciphers.polybius_square_cipher",
        "isExtraImport": true,
        "detail": "ciphers.polybius_square_cipher",
        "documentation": {}
    },
    {
        "label": "trithemius_cipher",
        "importPath": "ciphers.trithemius_cipher",
        "description": "ciphers.trithemius_cipher",
        "isExtraImport": true,
        "detail": "ciphers.trithemius_cipher",
        "documentation": {}
    },
    {
        "label": "trithemius_decipher",
        "importPath": "ciphers.trithemius_cipher",
        "description": "ciphers.trithemius_cipher",
        "isExtraImport": true,
        "detail": "ciphers.trithemius_cipher",
        "documentation": {}
    },
    {
        "label": "belazo_cipher",
        "importPath": "ciphers.belazo_cipher",
        "description": "ciphers.belazo_cipher",
        "isExtraImport": true,
        "detail": "ciphers.belazo_cipher",
        "documentation": {}
    },
    {
        "label": "belazo_decipher",
        "importPath": "ciphers.belazo_cipher",
        "description": "ciphers.belazo_cipher",
        "isExtraImport": true,
        "detail": "ciphers.belazo_cipher",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ciphers.matrix_cipher",
        "description": "ciphers.matrix_cipher",
        "isExtraImport": true,
        "detail": "ciphers.matrix_cipher",
        "documentation": {}
    },
    {
        "label": "format_input",
        "importPath": "utils.input_formatter",
        "description": "utils.input_formatter",
        "isExtraImport": true,
        "detail": "utils.input_formatter",
        "documentation": {}
    },
    {
        "label": "format_input",
        "importPath": "utils.input_formatter",
        "description": "utils.input_formatter",
        "isExtraImport": true,
        "detail": "utils.input_formatter",
        "documentation": {}
    },
    {
        "label": "format_blocks",
        "importPath": "utils.block_formatter",
        "description": "utils.block_formatter",
        "isExtraImport": true,
        "detail": "utils.block_formatter",
        "documentation": {}
    },
    {
        "label": "print_polybius_square",
        "importPath": "utils.print_square",
        "description": "utils.print_square",
        "isExtraImport": true,
        "detail": "utils.print_square",
        "documentation": {}
    },
    {
        "label": "text_to_numeric",
        "importPath": "utils.text_to_numeric",
        "description": "utils.text_to_numeric",
        "isExtraImport": true,
        "detail": "utils.text_to_numeric",
        "documentation": {}
    },
    {
        "label": "text_to_numeric",
        "importPath": "utils.text_to_numeric",
        "description": "utils.text_to_numeric",
        "isExtraImport": true,
        "detail": "utils.text_to_numeric",
        "documentation": {}
    },
    {
        "label": "atbash_cipher",
        "kind": 2,
        "importPath": "ciphers.atbash_cipher",
        "description": "ciphers.atbash_cipher",
        "peekOfCode": "def atbash_cipher(text: str) -> str:\n    \"\"\"Атбаш шифр.\"\"\"\n    alphabet = 'абвгдежзийклмнопрстуфхцчшщъыьэюя'\n    reverse_alphabet = alphabet[::-1] # переворачиваем алфавит \n    result = ''\n    for char in text:  # проходимся по каждому символу в тексте\n        if char in alphabet:  # если символ присутствует в алфавите\n            index = alphabet.index(char)  # найдем его индекс\n            result += reverse_alphabet[index]  # добавим в результат соответствующий символ из перевернутого алфавита\n        else:",
        "detail": "ciphers.atbash_cipher",
        "documentation": {}
    },
    {
        "label": "atbash_decipher",
        "kind": 2,
        "importPath": "ciphers.atbash_cipher",
        "description": "ciphers.atbash_cipher",
        "peekOfCode": "def atbash_decipher(text: str) -> str:\n    \"\"\"Расшифровка атбаш шифра.\"\"\"\n    alphabet = 'абвгдежзийклмнопрстуфхцчшщъыьэюя'\n    reverse_alphabet = alphabet[::-1]\n    result = '' \n    for char in text:  # проходимся по каждому символу в тексте\n        if char in reverse_alphabet:  # если символ присутствует в перевернутом алфавите\n            index = reverse_alphabet.index(char)  # найдем его индекс\n            result += alphabet[index]  # добавим в результат соответствующий символ из обычного алфавита\n        else:",
        "detail": "ciphers.atbash_cipher",
        "documentation": {}
    },
    {
        "label": "belazo_cipher",
        "kind": 2,
        "importPath": "ciphers.belazo_cipher",
        "description": "ciphers.belazo_cipher",
        "peekOfCode": "def belazo_cipher(text: str, key: str) -> str:\n    \"\"\"Шифр Белазо.\"\"\"\n    # Создаем таблицу алфавита, каждая строка - сдвиг на 1 букву\n    alphabet = 'абвгдежзийклмнопрстуфхцчшщъыьэюя'\n    # Преобразование текста и ключа в нижний регистр\n    text = text.lower()\n    key = key.lower()\n    # Шифрование текста\n    encrypted_text = ''\n    for i, char in enumerate(text):",
        "detail": "ciphers.belazo_cipher",
        "documentation": {}
    },
    {
        "label": "belazo_decipher",
        "kind": 2,
        "importPath": "ciphers.belazo_cipher",
        "description": "ciphers.belazo_cipher",
        "peekOfCode": "def belazo_decipher(text: str, key: str) -> str:\n    \"\"\"Дешифрование шифра Белазо.\"\"\"\n    # Создаем таблицу алфавита, каждая строка - сдвиг на 1 букву\n    alphabet = 'абвгдежзийклмнопрстуфхцчшщъыьэюя'\n    # Преобразование текста и ключа в нижний регистр\n    text = text.lower()\n    key = key.lower()\n    # Расшифрованный текст\n    decrypted_text = ''\n    for i, char in enumerate(text):",
        "detail": "ciphers.belazo_cipher",
        "documentation": {}
    },
    {
        "label": "caesar_cipher",
        "kind": 2,
        "importPath": "ciphers.caesar_cipher",
        "description": "ciphers.caesar_cipher",
        "peekOfCode": "def caesar_cipher(text: str, key: int) -> str:\n    \"\"\"Цезарь шифр с выбором ключа.\"\"\"\n    alphabet = 'абвгдежзийклмнопрстуфхцчшщъыьэюя'\n    encrypted_text = ''.join(alphabet[(alphabet.index(char) + key) % len(alphabet)] for char in text)\n    return encrypted_text\ndef caesar_decipher(text: str, key: int) -> str:\n    \"\"\"Расшифровка цезарь шифра с выбором ключа.\"\"\"\n    alphabet = 'абвгдежзийклмнопрстуфхцчшщъыьэюя'\n    decrypted_text = ''.join(alphabet[(alphabet.index(char) - key) % len(alphabet)] for char in text)\n    return decrypted_text",
        "detail": "ciphers.caesar_cipher",
        "documentation": {}
    },
    {
        "label": "caesar_decipher",
        "kind": 2,
        "importPath": "ciphers.caesar_cipher",
        "description": "ciphers.caesar_cipher",
        "peekOfCode": "def caesar_decipher(text: str, key: int) -> str:\n    \"\"\"Расшифровка цезарь шифра с выбором ключа.\"\"\"\n    alphabet = 'абвгдежзийклмнопрстуфхцчшщъыьэюя'\n    decrypted_text = ''.join(alphabet[(alphabet.index(char) - key) % len(alphabet)] for char in text)\n    return decrypted_text",
        "detail": "ciphers.caesar_cipher",
        "documentation": {}
    },
    {
        "label": "matrix_cipher",
        "kind": 2,
        "importPath": "ciphers.matrix_cipher",
        "description": "ciphers.matrix_cipher",
        "peekOfCode": "def matrix_cipher(text_numeric, key_matrix):\n    \"\"\"Матричный шифр.\"\"\"\n    encrypted_messages = []\n    print(\"<SDM> [matrix_cipher scope] encrypted_messages: \", encrypted_messages)\n    key_size = key_matrix.shape[0]\n    print(\"<SDM> [matrix_cipher scope] key_size: \", key_size)\n    # Подготовка текста к шифрованию: разбиение на векторы длиной key_size\n    text_chunks = [text_numeric[i:i+key_size] for i in range(0, len(text_numeric), key_size)]\n    print(\"<SDM> [matrix_cipher scope] text_chunks: \", text_chunks)\n    # Шифрование каждого вектора текста",
        "detail": "ciphers.matrix_cipher",
        "documentation": {}
    },
    {
        "label": "matrix_decipher",
        "kind": 2,
        "importPath": "ciphers.matrix_cipher",
        "description": "ciphers.matrix_cipher",
        "peekOfCode": "def matrix_decipher(encrypted_message, key_matrix):\n    \"\"\"Дешифрование матричного шифра.\"\"\"\n    decrypted_messages = []  \n    print(\"<SDM> [matrix_decipher scope] decrypted_messages: \", decrypted_messages)\n    alphabet = 'абвгдежзийклмнопрстуфхцчшщъыьэюя'  \n    key_size = key_matrix.shape[0]  \n    print(\"<SDM> [matrix_decipher scope] key_size: \", key_size)\n    split_message = [encrypted_message[i:i+2] for i in range(0, len(encrypted_message), 2)]  # Разбиваем зашифрованное сообщение на блоки по 2 символа\n    print(\"<SDM> [matrix_decipher scope] split_message: \", split_message)\n    vectors = [] ",
        "detail": "ciphers.matrix_cipher",
        "documentation": {}
    },
    {
        "label": "polybius_square_cipher",
        "kind": 2,
        "importPath": "ciphers.polybius_square_cipher",
        "description": "ciphers.polybius_square_cipher",
        "peekOfCode": "def polybius_square_cipher(text: str) -> str:\n    \"\"\"Квадрат Полибия.\"\"\"\n    # буквы с ключами (ij)  \n    polybius_table = {\n        'а': '11', 'б': '12', 'в': '13', 'г': '14', 'д': '15', 'е': '16',\n        'ж': '21', 'з': '22', 'и': '23', 'й': '24', 'к': '25', 'л': '26',\n        'м': '31', 'н': '32', 'о': '33', 'п': '34', 'р': '35', 'с': '36',\n        'т': '41', 'у': '42', 'ф': '43', 'х': '44', 'ц': '45', 'ч': '46',\n        'ш': '51', 'щ': '52', 'ъ': '53', 'ы': '54', 'ь': '55', 'э': '56',\n        'ю': '61', 'я': '62'",
        "detail": "ciphers.polybius_square_cipher",
        "documentation": {}
    },
    {
        "label": "polybius_square_decipher",
        "kind": 2,
        "importPath": "ciphers.polybius_square_cipher",
        "description": "ciphers.polybius_square_cipher",
        "peekOfCode": "def polybius_square_decipher(text: str) -> str:\n    \"\"\"Расшифровка квадрата Полибия.\"\"\"\n    # буквы с ключами (ij)  \n    polybius_table = {\n        '11': 'а', '12': 'б', '13': 'в', '14': 'г', '15': 'д', '16': 'е',\n        '21': 'ж', '22': 'з', '23': 'и', '24': 'й', '25': 'к', '26': 'л',\n        '31': 'м', '32': 'н', '33': 'о', '34': 'п', '35': 'р', '36': 'с',\n        '41': 'т', '42': 'у', '43': 'ф', '44': 'х', '45': 'ц', '46': 'ч',\n        '51': 'ш', '52': 'щ', '53': 'ъ', '54': 'ы', '55': 'ь', '56': 'э',\n        '61': 'ю', '62': 'я'",
        "detail": "ciphers.polybius_square_cipher",
        "documentation": {}
    },
    {
        "label": "trithemius_cipher",
        "kind": 2,
        "importPath": "ciphers.trithemius_cipher",
        "description": "ciphers.trithemius_cipher",
        "peekOfCode": "def trithemius_cipher(text: str) -> str:\n    \"\"\"Функция для шифрования текста методом Тритемия.\"\"\"\n    alphabet = 'абвгдежзийклмнопрстуфхцчшщъыьэюя' \n    n = len(alphabet)\n    encrypted_text = ''\n    for j, char in enumerate(text, start=1):  # перебираем символы текста, начиная с индекса 1\n        i = alphabet.index(char) + j - 1  # находим новый индекс символа\n        encrypted_text += alphabet[i % n]  # добавляем зашифрованный символ к зашифрованному тексту\n    return encrypted_text\ndef trithemius_decipher(text: str) -> str:",
        "detail": "ciphers.trithemius_cipher",
        "documentation": {}
    },
    {
        "label": "trithemius_decipher",
        "kind": 2,
        "importPath": "ciphers.trithemius_cipher",
        "description": "ciphers.trithemius_cipher",
        "peekOfCode": "def trithemius_decipher(text: str) -> str:\n    \"\"\"Функция для расшифровки текста, зашифрованного методом Тритемия.\"\"\"\n    alphabet = 'абвгдежзийклмнопрстуфхцчшщъыьэюя'  \n    n = len(alphabet)\n    decrypted_text = ''\n    for j, char in enumerate(text, start=1):  # перебираем символы текста, начиная с индекса 1\n        i = alphabet.index(char) - j + 1  # находим новый индекс символа\n        decrypted_text += alphabet[i % n]  # добавляем расшифрованный символ к расшифрованному тексту\n    return decrypted_text",
        "detail": "ciphers.trithemius_cipher",
        "documentation": {}
    },
    {
        "label": "format_blocks",
        "kind": 2,
        "importPath": "utils.block_formatter",
        "description": "utils.block_formatter",
        "peekOfCode": "def format_blocks(text: str) -> str:\n    \"\"\"Разделение строки на блоки по 5 символов.\"\"\"\n    return ' '.join([text[i:i+5] for i in range(0, len(text), 5)])",
        "detail": "utils.block_formatter",
        "documentation": {}
    },
    {
        "label": "format_input",
        "kind": 2,
        "importPath": "utils.input_formatter",
        "description": "utils.input_formatter",
        "peekOfCode": "def format_input(text: str) -> str:\n    \"\"\"Форматирование входной строки.\"\"\"\n    formatted_text = text.lower().replace('.', 'тчк').replace(',', 'зпт').replace('-', 'тире').replace(' ', '')\n    return formatted_text",
        "detail": "utils.input_formatter",
        "documentation": {}
    },
    {
        "label": "print_polybius_square",
        "kind": 2,
        "importPath": "utils.print_square",
        "description": "utils.print_square",
        "peekOfCode": "def print_polybius_square():\n    \"\"\"Вывод квадрата Полибия на экран.\"\"\"\n    print(\"Квадрат Полибия:\")\n    print(\"  1 2 3 4 5 6\")\n    print(\"1 а б в г д е\")\n    print(\"2 ж з и й к л\")\n    print(\"3 м н о п р с\")\n    print(\"4 т у ф х ц ч\")\n    print(\"5 ш щ ъ ы ь э\")\n    print(\"6 ю я\")",
        "detail": "utils.print_square",
        "documentation": {}
    },
    {
        "label": "text_to_numeric",
        "kind": 2,
        "importPath": "utils.text_to_numeric",
        "description": "utils.text_to_numeric",
        "peekOfCode": "def text_to_numeric(text):\n    \"\"\"Функция для преобразования текста в числовой эквивалент.\"\"\"\n    alphabet = 'абвгдежзийклмнопрстуфхцчшщъыьэюя'\n    numeric_values = []\n    for char in text:\n        if char.lower() in alphabet:\n            numeric_value = alphabet.index(char.lower()) + 1\n            numeric_values.append(numeric_value)\n    return numeric_values",
        "detail": "utils.text_to_numeric",
        "documentation": {}
    },
    {
        "label": "input_key_matrix",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def input_key_matrix(size):\n    \"\"\"Функция для ввода ключевой матрицы.\"\"\"\n    key_matrix = []\n    print(\"Введите элементы ключевой матрицы построчно:\")\n    for _ in range(size):\n        row = list(map(int, input().split()))\n        key_matrix.append(row)\n    return np.array(key_matrix)\ndef main():\n    while True:",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def main():\n    while True:\n        print(\"Выберите действие:\")\n        print(\"1. Зашифровать текст\")\n        print(\"2. Расшифровать текст\")\n        print(\"0. Выйти\")\n        action_choice = input(\"Введите номер действия: \")\n        if action_choice == '0':\n            print(\"Выход из программы.\")\n            break",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "keyword",
        "kind": 5,
        "importPath": "test",
        "description": "test",
        "peekOfCode": "keyword = input(\"Введите ключ-слово: \")\ntext = input(\"Введите текст для шифрования: \")\nkeyword = format_input(keyword)\nnumeric_text = text_to_numeric(keyword)\nnumeric_text.sort()\nnumeric_len = len(numeric_text)\ncols = numeric_len\nmatrix = []\nwhile True:\n    row_input = input(\"Введите числа через пробел (или нажмите Enter для завершения): \")",
        "detail": "test",
        "documentation": {}
    },
    {
        "label": "text",
        "kind": 5,
        "importPath": "test",
        "description": "test",
        "peekOfCode": "text = input(\"Введите текст для шифрования: \")\nkeyword = format_input(keyword)\nnumeric_text = text_to_numeric(keyword)\nnumeric_text.sort()\nnumeric_len = len(numeric_text)\ncols = numeric_len\nmatrix = []\nwhile True:\n    row_input = input(\"Введите числа через пробел (или нажмите Enter для завершения): \")\n    if not row_input:",
        "detail": "test",
        "documentation": {}
    },
    {
        "label": "keyword",
        "kind": 5,
        "importPath": "test",
        "description": "test",
        "peekOfCode": "keyword = format_input(keyword)\nnumeric_text = text_to_numeric(keyword)\nnumeric_text.sort()\nnumeric_len = len(numeric_text)\ncols = numeric_len\nmatrix = []\nwhile True:\n    row_input = input(\"Введите числа через пробел (или нажмите Enter для завершения): \")\n    if not row_input:\n        break",
        "detail": "test",
        "documentation": {}
    },
    {
        "label": "numeric_text",
        "kind": 5,
        "importPath": "test",
        "description": "test",
        "peekOfCode": "numeric_text = text_to_numeric(keyword)\nnumeric_text.sort()\nnumeric_len = len(numeric_text)\ncols = numeric_len\nmatrix = []\nwhile True:\n    row_input = input(\"Введите числа через пробел (или нажмите Enter для завершения): \")\n    if not row_input:\n        break\n    else:",
        "detail": "test",
        "documentation": {}
    },
    {
        "label": "numeric_len",
        "kind": 5,
        "importPath": "test",
        "description": "test",
        "peekOfCode": "numeric_len = len(numeric_text)\ncols = numeric_len\nmatrix = []\nwhile True:\n    row_input = input(\"Введите числа через пробел (или нажмите Enter для завершения): \")\n    if not row_input:\n        break\n    else:\n        row = list(map(int, row_input.split()))\n        matrix.append(row)",
        "detail": "test",
        "documentation": {}
    },
    {
        "label": "cols",
        "kind": 5,
        "importPath": "test",
        "description": "test",
        "peekOfCode": "cols = numeric_len\nmatrix = []\nwhile True:\n    row_input = input(\"Введите числа через пробел (или нажмите Enter для завершения): \")\n    if not row_input:\n        break\n    else:\n        row = list(map(int, row_input.split()))\n        matrix.append(row)\nprint(numeric_text)",
        "detail": "test",
        "documentation": {}
    },
    {
        "label": "matrix",
        "kind": 5,
        "importPath": "test",
        "description": "test",
        "peekOfCode": "matrix = []\nwhile True:\n    row_input = input(\"Введите числа через пробел (или нажмите Enter для завершения): \")\n    if not row_input:\n        break\n    else:\n        row = list(map(int, row_input.split()))\n        matrix.append(row)\nprint(numeric_text)\nprint(keyword)",
        "detail": "test",
        "documentation": {}
    }
]